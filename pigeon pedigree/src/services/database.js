        // Database service for React components
class DatabaseService {
  static getDevStorage() {
    const data = localStorage.getItem('pigeonPedigreeData');
    const parsed = data ? JSON.parse(data) : { birds: [], settings: {}, nextId: 1 };
    // One-time migration: remove autogenerated placeholder names like "Bird N"
    try {
      parsed.migrations = parsed.migrations || {};
      if (!parsed.migrations.placeholderNamesCleaned) {
        const before = JSON.stringify(parsed.birds);
        const placeholderRegex = /^bird\s+\d+$/i;
        parsed.birds = (parsed.birds || []).map(b => ({
          ...b,
          name: (typeof b.name === 'string' && placeholderRegex.test(b.name.trim())) ? '' : (b.name || '')
        }));
        // Only write back if something actually changed
        if (before !== JSON.stringify(parsed.birds)) {
          parsed.migrations.placeholderNamesCleaned = true;
          localStorage.setItem('pigeonPedigreeData', JSON.stringify(parsed));
        } else {
          parsed.migrations.placeholderNamesCleaned = true;
          localStorage.setItem('pigeonPedigreeData', JSON.stringify(parsed));
        }
      }
    } catch (e) {
      // Fail-safe: do nothing if migration fails
      console.warn('Placeholder name cleanup migration skipped:', e);
    }
    // Sanitize birds: normalize ids and parent refs to numbers; ensure timestamps
    try {
      const birds = Array.isArray(parsed.birds) ? parsed.birds : [];
      let changed = false;
      parsed.birds = birds.map(b => {
        const nb = { ...b };
        const orig = JSON.stringify(nb);
        if (nb.id != null) nb.id = Number(nb.id);
        // Normalize sire_id/dam_id: null if empty/invalid; number if valid
        const norm = (v) => {
          if (v === undefined || v === null) return null;
          if (typeof v === 'string' && v.trim() === '') return null;
          const n = Number(v);
          return Number.isFinite(n) && n > 0 ? n : null;
        };
        nb.sire_id = norm(nb.sire_id);
        nb.dam_id = norm(nb.dam_id);
        if (!nb.created_at) nb.created_at = new Date().toISOString();
        if (!nb.updated_at) nb.updated_at = nb.created_at;
        if (orig !== JSON.stringify(nb)) changed = true;
        return nb;
      });
      if (changed) {
        localStorage.setItem('pigeonPedigreeData', JSON.stringify(parsed));
      }
    } catch (e) {
      console.warn('Dev storage sanitize skipped:', e);
    }
    return parsed;
  }

  static setDevStorage(data) {
    localStorage.setItem('pigeonPedigreeData', JSON.stringify(data));
  }

  static async query(sql, params = []) {
    if (window.electronAPI) {
      return await window.electronAPI.dbQuery(sql, params);
    } else {
      // Development mode - use localStorage
      console.log('Dev DB Query:', sql, params);
      const data = this.getDevStorage();
      // Simple SQL parsing for development (handle common patterns we use)
      if (sql.toLowerCase().includes('select count(*) as count from birds')) {
        let birds = [...data.birds];
        if (sql.toLowerCase().includes('where sex = ?')) {
          const sex = params[0];
          birds = birds.filter(b => b.sex === sex);
        } else if (sql.toLowerCase().includes("where created_at >")) {
          const thirtyDaysAgo = new Date();
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          birds = birds.filter(b => new Date(b.created_at) > thirtyDaysAgo);
        }
        return [{ count: birds.length }];
      }

      if (sql.includes('SELECT') && sql.includes('FROM birds')) {
        let birds = [...data.birds];

        // WHERE id = ? (or WHERE b.id = ?)
        if (/where\s+(b\.)?id\s*=\s*\?/i.test(sql) && params.length > 0) {
          const id = params[0];
          birds = birds.filter(b => b.id == id);
        }

        // WHERE sire_id = ? OR dam_id = ?
        if (/where\s+sire_id\s*=\s*\?\s+or\s+dam_id\s*=\s*\?/i.test(sql) && params.length >= 2) {
          const p1 = params[0];
          const p2 = params[1];
          birds = birds.filter(b => b.sire_id == p1 || b.dam_id == p2);
        }

        // WHERE name LIKE ? OR ring_number LIKE ? (with optional table alias b.)
        if (/where\s+(b\.)?name\s+like\s+\?\s+or\s+(b\.)?ring_number\s+like\s+\?/i.test(sql) && params.length >= 2) {
          const t1 = String(params[0]).replace(/%/g, '').toLowerCase();
          const t2 = String(params[1]).replace(/%/g, '').toLowerCase();
          birds = birds.filter(b =>
            (b.name && b.name.toLowerCase().includes(t1)) ||
            (b.ring_number && b.ring_number.toLowerCase().includes(t2))
          );
        }

        // ORDER BY created_at DESC
        if (/order\s+by\s+created_at\s+desc/i.test(sql)) {
          birds.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
        }

        // ORDER BY name
        if (/order\s+by\s+name(\s+asc)?/i.test(sql)) {
          birds.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
        }

        // LIMIT n
        const limitMatch = sql.match(/limit\s+(\d+)/i);
        if (limitMatch) {
          const n = parseInt(limitMatch[1], 10);
          if (!isNaN(n)) birds = birds.slice(0, n);
        }

        return birds.map(bird => ({
          ...bird,
          sire_name: data.birds.find(b => b.id === bird.sire_id)?.name || null,
          dam_name: data.birds.find(b => b.id === bird.dam_id)?.name || null
        }));
      }

      return [];
    }
  }

  static async run(sql, params = []) {
    if (window.electronAPI) {
      return await window.electronAPI.dbRun(sql, params);
    } else {
      // Development mode - use localStorage
      console.log('Dev DB Run:', sql, params);
      const data = this.getDevStorage();
      
      if (sql.includes('INSERT INTO birds')) {
        const newBird = {
          id: data.nextId,
          name: params[0] ?? '',
          ring_number: params[1],
          sex: params[2],
          color: params[3],
          breed: params[4],
          year: params[5],
          notes: params[6],
          body_photo: params[7],
          eye_photo: params[8],
          sire_id: params[9],
          dam_id: params[10],
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        };
        data.birds.push(newBird);
        data.nextId++;
        this.setDevStorage(data);
        console.log('Bird saved via run method:', newBird);
        return { lastID: newBird.id, changes: 1 };
      }
      
      if (/update\s+birds\s+set/i.test(sql)) {
        // Expect params in the same order as in updateBird() above, ending with id
        const [
          name, ring_number, sex, color, breed, year, notes,
          body_photo, eye_photo, sire_id, dam_id, id
        ] = params;
        const idx = data.birds.findIndex(b => b.id == id);
        if (idx !== -1) {
          const existing = data.birds[idx];
          data.birds[idx] = {
            ...existing,
            name: name ?? existing.name,
            ring_number: ring_number ?? existing.ring_number,
            sex: sex ?? existing.sex,
            color: color ?? existing.color,
            breed: breed ?? existing.breed,
            year: year ?? existing.year,
            notes: notes ?? existing.notes,
            body_photo: body_photo ?? existing.body_photo,
            eye_photo: eye_photo ?? existing.eye_photo,
            sire_id: sire_id ?? existing.sire_id,
            dam_id: dam_id ?? existing.dam_id,
            updated_at: new Date().toISOString(),
          };
          this.setDevStorage(data);
          console.log('Bird updated via run method:', data.birds[idx]);
          return { changes: 1 };
        }
        return { changes: 0 };
      }

      if (/delete\s+from\s+birds\s+where\s+id\s*=\s*\?/i.test(sql)) {
        const id = params[0];
        const before = data.birds.length;
        data.birds = data.birds.filter(b => b.id != id);
        this.setDevStorage(data);
        return { changes: before - data.birds.length };
      }
      
      return { lastID: Math.floor(Math.random() * 1000), changes: 1 };
    }
  }

  // Bird operations
  static async getAllBirds() {
    if (window.electronAPI) {
      return await this.query(`
        SELECT b.*, 
               s.name as sire_name, 
               d.name as dam_name
        FROM birds b
        LEFT JOIN birds s ON b.sire_id = s.id
        LEFT JOIN birds d ON b.dam_id = d.id
        ORDER BY b.created_at DESC
      `);
    } else {
      // Development mode
      const data = this.getDevStorage();
      return data.birds.map(bird => ({
        ...bird,
        sire_name: data.birds.find(b => b.id === bird.sire_id)?.name || null,
        dam_name: data.birds.find(b => b.id === bird.dam_id)?.name || null
      })).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
    }
  }

  static async getBirdById(id) {
    if (window.electronAPI) {
      const birds = await this.query(`
        SELECT b.*, 
               s.name as sire_name, 
               d.name as dam_name
        FROM birds b
        LEFT JOIN birds s ON b.sire_id = s.id
        LEFT JOIN birds d ON b.dam_id = d.id
        WHERE b.id = ?
      `, [id]);
      
      return birds.length > 0 ? birds[0] : null;
    } else {
      // Development mode
      const data = this.getDevStorage();
      const bird = data.birds.find(b => b.id == id);
      if (!bird) return null;
      
      return {
        ...bird,
        sire_name: data.birds.find(b => b.id === bird.sire_id)?.name || null,
        dam_name: data.birds.find(b => b.id === bird.dam_id)?.name || null
      };
    }
  }

  static async searchBirds(searchTerm) {
    return await this.query(`
      SELECT b.*, 
             s.name as sire_name, 
             d.name as dam_name
      FROM birds b
      LEFT JOIN birds s ON b.sire_id = s.id
      LEFT JOIN birds d ON b.dam_id = d.id
      WHERE b.name LIKE ? OR b.ring_number LIKE ?
      ORDER BY b.name
    `, [`%${searchTerm}%`, `%${searchTerm}%`]);
  }

  static async getBirdsForAutocomplete(searchTerm = '') {
    if (window.electronAPI) {
      const query = searchTerm 
        ? `SELECT id, name, ring_number, sex FROM birds WHERE name LIKE ? OR ring_number LIKE ? ORDER BY name`
        : `SELECT id, name, ring_number, sex FROM birds ORDER BY name`;
      
      const params = searchTerm ? [`%${searchTerm}%`, `%${searchTerm}%`] : [];
      return await this.query(query, params);
    } else {
      // Development mode
      const data = this.getDevStorage();
      let birds = data.birds.map(bird => ({
        id: bird.id,
        name: bird.name,
        ring_number: bird.ring_number,
        sex: bird.sex
      }));
      
      if (searchTerm) {
        const term = searchTerm.toLowerCase();
        birds = birds.filter(bird => 
          (bird.name && bird.name.toLowerCase().includes(term)) ||
          (bird.ring_number && bird.ring_number.toLowerCase().includes(term))
        );
      }
      
      return birds.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
    }
  }

  static async createBird(birdData) {
    const {
      name, ring_number, sex, color, breed, year, notes,
      body_photo, eye_photo, sire_id, dam_id
    } = birdData;

    if (window.electronAPI) {
      // Production mode - use SQLite
      const result = await this.run(`
        INSERT INTO birds (
          name, ring_number, sex, color, breed, year, notes,
          body_photo, eye_photo, sire_id, dam_id
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `, [
        name, ring_number, sex, color, breed, year, notes,
        body_photo, eye_photo, sire_id, dam_id
      ]);
      return result.lastID;
    } else {
      // Development mode - use localStorage
      const data = this.getDevStorage();
      const newBird = {
        id: data.nextId++,
        name: name || '',
        ring_number: ring_number || null,
        sex: sex,
        color: color || null,
        breed: breed || null,
        year: year || new Date().getFullYear(),
        notes: notes || null,
        body_photo: body_photo || null,
        eye_photo: eye_photo || null,
        sire_id: sire_id || null,
        dam_id: dam_id || null,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };
      
      data.birds.push(newBird);
      this.setDevStorage(data);
      
      console.log('Bird saved to localStorage:', newBird);
      return newBird.id;
    }
  }

  static async checkDuplicateRingNumber(ringNumber, year, excludeId = null) {
    if (!ringNumber) return false;
    
    if (window.electronAPI) {
      // Production mode - check SQLite
      const query = `
        SELECT id FROM birds 
        WHERE ring_number = ? AND year = ? 
        ${excludeId ? 'AND id != ?' : ''}
        LIMIT 1
      `;
      const params = [ringNumber, year];
      if (excludeId) params.push(excludeId);
      
      const result = await this.query(query, params);
      return result.length > 0;
    } else {
      // Development mode - check localStorage
      const data = this.getDevStorage();
      return data.birds.some(bird => 
        bird.ring_number === ringNumber && 
        bird.year === year && 
        (excludeId ? bird.id != excludeId : true)
      );
    }
  }

  static async updateBird(id, birdData) {
    const {
      name, ring_number, sex, color, breed, year, notes,
      body_photo, eye_photo, sire_id, dam_id
    } = birdData;
    if (window.electronAPI) {
      await this.run(`
        UPDATE birds SET 
          name = ?, ring_number = ?, sex = ?, color = ?, breed = ?, 
          year = ?, notes = ?, body_photo = ?, eye_photo = ?, 
          sire_id = ?, dam_id = ?, updated_at = CURRENT_TIMESTAMP
        WHERE id = ?
      `, [
        name, ring_number, sex, color, breed, year, notes,
        body_photo, eye_photo, sire_id, dam_id, id
      ]);
    } else {
      // Development mode - update in localStorage
      const data = this.getDevStorage();
      const idx = data.birds.findIndex(b => b.id == id);
      if (idx !== -1) {
        const existing = data.birds[idx];
        data.birds[idx] = {
          ...existing,
          name: name !== undefined ? name : existing.name,
          ring_number: ring_number !== undefined ? ring_number : existing.ring_number,
          sex: sex !== undefined ? sex : existing.sex,
          color: color !== undefined ? color : existing.color,
          breed: breed !== undefined ? breed : existing.breed,
          year: year !== undefined ? year : existing.year,
          notes: notes !== undefined ? notes : existing.notes,
          body_photo: body_photo !== undefined ? body_photo : existing.body_photo,
          eye_photo: eye_photo !== undefined ? eye_photo : existing.eye_photo,
          sire_id: sire_id !== undefined ? sire_id : existing.sire_id,
          dam_id: dam_id !== undefined ? dam_id : existing.dam_id,
          updated_at: new Date().toISOString(),
        };
        this.setDevStorage(data);
      }
    }
  }

  static async deleteBird(id) {
    if (window.electronAPI) {
      await this.run('UPDATE birds SET sire_id = NULL WHERE sire_id = ?', [id]);
      await this.run('UPDATE birds SET dam_id = NULL WHERE dam_id = ?', [id]);
      await this.run('DELETE FROM birds WHERE id = ?', [id]);
    } else {
      // Development mode - delete from localStorage
      const data = this.getDevStorage();
      data.birds = data.birds
        .map(b => ({
          ...b,
          sire_id: b.sire_id == id ? null : b.sire_id,
          dam_id: b.dam_id == id ? null : b.dam_id
        }))
        .filter(b => b.id != id);
      this.setDevStorage(data);
    }
  }

  static async getOffspring(parentId) {
    if (window.electronAPI) {
      return await this.query(`
        SELECT * FROM birds 
        WHERE sire_id = ? OR dam_id = ?
        ORDER BY name
      `, [parentId, parentId]);
    } else {
      // Development mode - filter from localStorage correctly
      const data = this.getDevStorage();
      return data.birds
        .filter(b => b.sire_id == parentId || b.dam_id == parentId)
        .sort((a, b) => (a.name || '').localeCompare(b.name || ''));
    }
  }

  // Pedigree operations
  static async getPedigree(birdId, generations = 4) {
    const pedigree = {};
    // Cache for each generation level to avoid infinite recursion but allow full ancestry
    const buildingCache = new Map(); // id -> Promise to avoid duplicate work
    
    const getBirdWithAncestors = async (id, generation, path = new Set()) => {
      if (!id || generation > generations) return null;
      if (path.has(id)) return null; // prevent cycles along current path
      
      // Create a unique cache key that includes generation depth
      const cacheKey = `${id}-${generation}`;
      if (buildingCache.has(cacheKey)) {
        return await buildingCache.get(cacheKey);
      }

      const nextPath = new Set(path);
      nextPath.add(id);

      // Create promise for this bird's resolution
      const birdPromise = (async () => {
        const bird = await this.getBirdById(id);
        if (!bird && process.env.NODE_ENV !== 'production') {
          console.warn('Pedigree: missing bird for id', id, 'at gen', generation);
        }
        if (!bird) return null;

        // Debug logging for parent relationships
        if (process.env.NODE_ENV !== 'production') {
          console.log(`Pedigree: Bird ${bird.id} (${bird.name || bird.ring_number}) at gen ${generation}:`, {
            sire_id: bird.sire_id,
            dam_id: bird.dam_id,
            sire_type: typeof bird.sire_id,
            dam_type: typeof bird.dam_id
          });
        }

        const birdWithAncestors = { ...bird };

        if (generation < generations) {
          birdWithAncestors.sire = await getBirdWithAncestors(bird.sire_id, generation + 1, nextPath);
          birdWithAncestors.dam = await getBirdWithAncestors(bird.dam_id, generation + 1, nextPath);
          
          // Debug what we got back
          if (process.env.NODE_ENV !== 'production') {
            console.log(`Pedigree: Resolved parents for ${bird.id}:`, {
              sire: birdWithAncestors.sire ? `${birdWithAncestors.sire.id} (${birdWithAncestors.sire.name || birdWithAncestors.sire.ring_number})` : 'null',
              dam: birdWithAncestors.dam ? `${birdWithAncestors.dam.id} (${birdWithAncestors.dam.name || birdWithAncestors.dam.ring_number})` : 'null'
            });
          }
        }

        return birdWithAncestors;
      })();

      buildingCache.set(cacheKey, birdPromise);
      return await birdPromise;
    };

    pedigree.bird = await getBirdWithAncestors(birdId, 1);
    console.log('pedigreeData', pedigree);
    return pedigree;
  }

  static async findCommonAncestors(birdId, generations = 5) {
    const pedigree = await this.getPedigree(birdId, generations);
    const ancestors = new Map(); // Tracks first occurrence of each bird
    const duplicates = []; // Tracks groups of duplicate birds
    
    const collectAncestors = (bird, path = '', isMainBird = false) => {
      if (!bird) return;
      
      const key = bird.id;
      
      // Don't count the main bird as a common ancestor
      if (!isMainBird) {
        if (ancestors.has(key)) {
          // This is a duplicate bird
          const existing = ancestors.get(key);
          const duplicateGroup = duplicates.find(group => group.id === key);
          
          if (duplicateGroup) {
            // Add this occurrence to existing group
            duplicateGroup.occurrences.push({
              bird,
              path
            });
          } else {
            // Create new duplicate group with both occurrences
            duplicates.push({
              id: key,
              bird,
              occurrences: [
                { bird: existing.bird, path: existing.path },
                { bird, path }
              ]
            });
          }
        } else {
          // First time seeing this bird
          ancestors.set(key, { bird, path });
        }
      }
      
      if (bird.sire) collectAncestors(bird.sire, path + 'S', false);
      if (bird.dam) collectAncestors(bird.dam, path + 'D', false);
    };
    
    collectAncestors(pedigree.bird, '', true);
    
    // Assign a unique color to each duplicate group
    const colorPalette = [
      [255, 200, 200], // Light red
      [200, 230, 200], // Light green
      [200, 200, 255], // Light blue
      [255, 255, 200], // Light yellow
      [255, 200, 255], // Light purple
      [200, 255, 255], // Light cyan
      [255, 220, 200], // Light orange
      [220, 200, 255], // Light lavender
      [200, 240, 240], // Light teal
      [255, 220, 220], // Light pink
      [220, 255, 200], // Light lime
      [240, 200, 200], // Light salmon
      [200, 200, 220], // Light periwinkle
      [255, 240, 200], // Light peach
      [220, 220, 255], // Light periwinkle blue
      [200, 255, 220]  // Light mint
    ];
    
    // Create a map of bird ID to color
    const colorMap = new Map();
    duplicates.forEach((group, index) => {
      const color = colorPalette[index % colorPalette.length];
      colorMap.set(group.id, {
        color: `rgb(${color[0]}, ${color[1]}, ${color[2]})`,
        occurrences: group.occurrences.length + 1 // +1 for the first occurrence
      });
    });
    
    console.log('=== Common Ancestors Detection ===');
    console.log('Total unique ancestors:', ancestors.size);
    console.log('Duplicate groups:', duplicates.map(g => ({
      id: g.id,
      name: g.bird.name,
      ring: g.bird.ring_number,
      occurrences: g.occurrences.length + 1
    })));
    
    return {
      duplicates: colorMap,
      duplicateGroups: duplicates,
      allDuplicateIds: Array.from(new Set(duplicates.map(g => g.id)))
    };
  }

  // Settings operations
  static async getSetting(key) {
    if (window.electronAPI) {
      const result = await this.query('SELECT value FROM settings WHERE key = ?', [key]);
      return result.length > 0 ? result[0].value : null;
    } else {
      // Development mode - use localStorage
      const data = this.getDevStorage();
      return data.settings[key] || null;
    }
  }

  static async getSettings() {
    if (window.electronAPI) {
      const result = await this.query('SELECT key, value FROM settings');
      const settings = {};
      result.forEach(row => {
        settings[row.key] = row.value;
      });
      return settings;
    } else {
      // Development mode - use localStorage
      const data = this.getDevStorage();
      return data.settings || {};
    }
  }

  static async setSetting(key, value) {
    if (window.electronAPI) {
      await this.run(`
        INSERT OR REPLACE INTO settings (key, value, updated_at) 
        VALUES (?, ?, CURRENT_TIMESTAMP)
      `, [key, value]);
    } else {
      // Development mode - use localStorage
      const data = this.getDevStorage();
      data.settings[key] = value;
      this.setDevStorage(data);
    }
  }

  // Statistics
  static async getStats() {
    const totalBirds = await this.query('SELECT COUNT(*) as count FROM birds');
    const maleCount = await this.query('SELECT COUNT(*) as count FROM birds WHERE sex = ?', ['male']);
    const femaleCount = await this.query('SELECT COUNT(*) as count FROM birds WHERE sex = ?', ['female']);
    const recentBirds = await this.query(`
      SELECT COUNT(*) as count FROM birds 
      WHERE created_at > datetime('now', '-30 days')
    `);

    return {
      totalBirds: totalBirds[0]?.count || 0,
      maleCount: maleCount[0]?.count || 0,
      femaleCount: femaleCount[0]?.count || 0,
      recentBirds: recentBirds[0]?.count || 0
    };
  }
}

export default DatabaseService;
